"""
FAZA D.1 — AutoDoc Writer
--------------------------
Markdown documentation writer for AutoDoc system.

Generates:
- overview.md - System overview
- runtime_api.md - Runtime API reference
- module_api.md - Module API reference
- capabilities.md - Capability system documentation
- events.md - Event Bus documentation
- reactive_modules.md - Reactive modules documentation
- state_management.md - State management documentation

Plus JSON schemas under docs/schemas/
"""

from __future__ import annotations

import os
import json
import shutil
from typing import Any, Dict, List
from datetime import datetime


class AutoDocWriter:
    """
    Markdown documentation writer for AutoDoc system.

    Takes JSON model and generates comprehensive Markdown documentation.
    """

    def __init__(self, model: Dict[str, Any], docs_path: str, schemas_path: str):
        """
        Initialize AutoDoc writer.

        Args:
            model: JSON model from AutoDocBuilder
            docs_path: Path to docs/generated directory
            schemas_path: Path to docs/schemas directory
        """
        self.model = model
        self.docs_path = docs_path
        self.schemas_path = schemas_path

    # ================================================================
    # DIRECTORY MANAGEMENT
    # ================================================================

    def clean_docs_dir(self):
        """Remove all files from docs directory."""
        if os.path.exists(self.docs_path):
            for filename in os.listdir(self.docs_path):
                filepath = os.path.join(self.docs_path, filename)
                if os.path.isfile(filepath):
                    os.remove(filepath)

    def create_docs_structure(self):
        """Ensure docs directory structure exists."""
        os.makedirs(self.docs_path, exist_ok=True)
        os.makedirs(self.schemas_path, exist_ok=True)

    # ================================================================
    # MARKDOWN GENERATORS
    # ================================================================

    def render_overview_md(self) -> str:
        """
        Generate overview.md - main system overview.

        Returns:
            Path to generated file
        """
        runtime = self.model.get("runtime", {})
        metadata = self.model.get("metadata", {})
        modules = self.model.get("modules", [])
        capabilities = self.model.get("capabilities", {})
        events = self.model.get("events", {})

        content = f"""# Senti LLM Runtime - System Overview

**Generated:** {metadata.get('generated_at', 'unknown')}
**Version:** {runtime.get('phase', 'unknown')}
**Generator:** {metadata.get('generator', 'AutoDocBuilder')}

---

## System Architecture

{runtime.get('name', 'Senti LLM Runtime')} is a modular plugin-based runtime system implementing FAZA phases 36-42.

### Core Features

"""

        # Add features
        for feature in runtime.get("features", []):
            content += f"- {feature}\n"

        content += f"""

### Components

"""

        # Add components
        for component in runtime.get("components", []):
            content += f"- `{component}`\n"

        content += f"""

---

## Statistics

- **Loaded Modules:** {len(modules)}
- **Capabilities:** {len(capabilities)}
- **Event Types:** {len(events.get('registered_types', []))}

---

## Quick Links

- [Runtime API](runtime_api.md) - Runtime system API reference
- [Module API](module_api.md) - Module development API
- [Capabilities](capabilities.md) - Capability system documentation
- [Events](events.md) - Event Bus documentation
- [Reactive Modules](reactive_modules.md) - Reactive module patterns
- [State Management](state_management.md) - Persistent state system

---

## Getting Started

### Loading a Module

```python
from senti_core_module.senti_llm.runtime.llm_runtime_manager import LLMRuntimeManager

manager = LLMRuntimeManager()
result = manager.handle_input("load path/to/module.py")
```

### Running a Module

```python
result = manager.handle_input("run module_name payload_key=value")
```

### Querying Status

```python
result = manager.handle_input("status")
```

---

*Generated by AutoDocBuilder (FAZA D.1)*
"""

        return self.save_to_docs("overview.md", content)

    def render_runtime_api_md(self) -> str:
        """
        Generate runtime_api.md - Runtime API reference.

        Returns:
            Path to generated file
        """
        runtime = self.model.get("runtime", {})

        content = f"""# Runtime API Reference

**Phase:** {runtime.get('phase', 'unknown')}

Complete API reference for the Senti LLM Runtime system.

---

## LLMRuntimeManager

Main entry point for runtime operations.

### Initialization

```python
from senti_core_module.senti_llm.runtime.llm_runtime_manager import LLMRuntimeManager

manager = LLMRuntimeManager()
```

### Methods

#### `handle_input(input_str: str) -> Dict[str, Any]`

Process a command string and return result.

**Parameters:**
- `input_str`: Command string (e.g., "load path/to/module.py", "run module_name", "status")

**Returns:**
- Dict with `input`, `runtime_action`, and `result` keys

**Example:**

```python
result = manager.handle_input("status")
print(result["result"]["data"]["phase"])  # "FAZA 42"
```

---

## ExecutionOrchestrator

Orchestrates runtime action execution.

### Methods

#### `execute(action: RuntimeAction) -> Dict[str, Any]`

Execute a runtime action.

**Parameters:**
- `action`: RuntimeAction object

**Returns:**
- Dict with `ok`, `action_type`, and `data`/`error` keys

---

## ModuleLoader

Loads and validates modules.

### Methods

#### `load(module_path: str) -> Dict[str, Any]`

Load module from file path.

**Parameters:**
- `module_path`: Absolute path to module .py file

**Returns:**
- Dict with `ok`, `message`, `module`, `capabilities_granted`, etc.

**Example:**

```python
result = loader.load("senti_core_module/senti_llm/modules/my_module.py")
```

#### `run_module(name: str, payload: dict) -> Any`

Execute loaded module.

**Parameters:**
- `name`: Module name
- `payload`: Execution payload dict

**Returns:**
- Module execution result

---

## CapabilityManager

Manages capability grants and validation.

### Methods

#### `create_capability_map(manifest: Dict, module_name: str, event_bus: EventBus) -> Dict[str, Any]`

Create capability map for module.

**Parameters:**
- `manifest`: Module manifest dict
- `module_name`: Module name
- `event_bus`: EventBus instance

**Returns:**
- Dict of capability name -> capability proxy objects

---

## EventBus

Publish/subscribe event system (FAZA 41).

### Methods

#### `subscribe(event_type: str, handler: Callable) -> None`

Subscribe to event type.

**Parameters:**
- `event_type`: Event type identifier
- `handler`: Handler function `(event_context) -> Any`

#### `publish(event_type: str, event_context: EventContext) -> List[Any]`

Publish event to subscribers.

**Parameters:**
- `event_type`: Event type identifier
- `event_context`: EventContext object

**Returns:**
- List of handler results

#### `list_event_types() -> List[str]`

List all registered event types.

**Returns:**
- List of event type strings

#### `list_handlers(event_type: str) -> List[Callable]`

List handlers for event type.

**Parameters:**
- `event_type`: Event type identifier

**Returns:**
- List of handler functions

---

## StateManager

Persistent state management (FAZA 40).

### Methods

#### `load_state(module_name: str, manifest: Dict, storage: ModuleStorage) -> ModuleState`

Load or initialize module state.

**Parameters:**
- `module_name`: Module name
- `manifest`: Module manifest
- `storage`: ModuleStorage instance

**Returns:**
- ModuleState object

---

## ModuleState

Per-module persistent state.

### Methods

#### `get(key: str, default: Any = None) -> Any`

Get state value.

#### `set(key: str, value: Any) -> None`

Set state value.

#### `update(data: Dict[str, Any]) -> None`

Merge dict into state.

#### `delete(key: str) -> bool`

Delete state key.

#### `save() -> bool`

Save state to disk.

#### `refresh() -> bool`

Reload state from disk.

#### `rollback() -> bool`

Revert to last saved state.

#### `reset() -> bool`

Reset to default_state.

---

## RuntimeAction

Action object for orchestrator.

### Attributes

- `action_type: str` - Action type identifier
- `source: str` - Action source
- `payload: Dict[str, Any]` - Action payload

---

## Command Reference

### System Commands

- `status` - Query runtime status
- `help` - Show help message

### Module Commands

- `load <path>` - Load module from path
- `list` - List loaded modules
- `run <module> [key=value...]` - Run module with payload

---

*Generated by AutoDocBuilder (FAZA D.1)*
"""

        return self.save_to_docs("runtime_api.md", content)

    def render_capabilities_md(self) -> str:
        """
        Generate capabilities.md - capability system documentation.

        Returns:
            Path to generated file
        """
        capabilities = self.model.get("capabilities", {})

        content = f"""# Capability System

**Total Capabilities:** {len(capabilities)}

The capability system provides secure, fine-grained access control for modules.

---

## Available Capabilities

"""

        # Group by category
        categories: Dict[str, List[Dict[str, Any]]] = {}

        for cap_name, cap_def in capabilities.items():
            category = cap_def.get("category", "other")

            if category not in categories:
                categories[category] = []

            categories[category].append({
                "name": cap_name,
                **cap_def
            })

        # Render by category
        for category, caps in sorted(categories.items()):
            content += f"\n### {category.title()} Capabilities\n\n"

            for cap in sorted(caps, key=lambda c: c["name"]):
                content += f"""#### `{cap['name']}`

**Level:** {cap.get('level', 'unknown')}
**Description:** {cap.get('description', 'No description')}

"""

        content += """
---

## Requesting Capabilities

Capabilities are declared in the module manifest:

```python
MODULE_MANIFEST = {
    "name": "my_module",
    "capabilities": {
        "requires": ["log.basic", "storage.write"],
        "optional": ["event.publish"]
    }
}
```

---

## Security Levels

- **safe**: Available to all modules
- **controlled**: Requires explicit permission
- **restricted**: System-level only

---

*Generated by AutoDocBuilder (FAZA D.1)*
"""

        return self.save_to_docs("capabilities.md", content)

    def render_events_md(self) -> str:
        """
        Generate events.md - Event Bus documentation.

        Returns:
            Path to generated file
        """
        events = self.model.get("events", {})
        registered_types = events.get("registered_types", [])
        subscriptions = events.get("subscriptions", {})

        content = f"""# Event Bus System

**Total Event Types:** {len(registered_types)}

The Event Bus (FAZA 41) provides publish/subscribe messaging between modules.

---

## System Events

"""

        for event_type in events.get("system_events", []):
            content += f"- `{event_type}`\n"

        content += f"""

---

## Registered Event Types

"""

        for event_type in sorted(registered_types):
            handler_count = subscriptions.get(event_type, {}).get("handler_count", 0)
            content += f"- `{event_type}` — {handler_count} handler(s)\n"

        content += """

---

## Publishing Events

```python
# In your module
def run(self, payload):
    if self.event_publish:
        self.event_publish.publish(
            event_type="custom.test",
            payload={"data": "value"},
            category="demo",
            priority=5
        )
```

---

## Subscribing to Events (Manual - FAZA 41)

```python
# In init() hook
def init(self):
    if self.event_subscribe:
        self.event_subscribe.subscribe("module.loaded", self.on_module_loaded)

def on_module_loaded(self, event_context):
    print(f"Module loaded: {event_context.payload['module_name']}")
    return {"handled": True}
```

---

## Event Context Structure

```python
class EventContext:
    event_type: str      # Event type identifier
    source: str          # Publisher module name
    payload: Dict        # Event data
    category: str        # Event category
    priority: int        # Priority (0-10)
    timestamp: float     # Unix timestamp
```

---

*Generated by AutoDocBuilder (FAZA D.1)*
"""

        return self.save_to_docs("events.md", content)

    def render_reactive_md(self) -> str:
        """
        Generate reactive_modules.md - reactive module documentation.

        Returns:
            Path to generated file
        """
        modules = self.model.get("modules", [])

        # Find modules with reactive handlers
        reactive_modules = [m for m in modules if m.get("reactive", {}).get("enabled")]

        content = f"""# Reactive Modules

**Modules with Reactive Handlers:** {len(reactive_modules)}

Reactive modules (FAZA 42) declare event handlers in the manifest for automatic registration.

---

## Reactive vs Manual Subscription

| Feature | FAZA 41 (Manual) | FAZA 42 (Reactive) |
|---------|------------------|-------------------|
| Declaration | In `init()` hook | In manifest |
| Registration | Runtime subscription call | Automatic on load |
| Handler Discovery | Implicit | Explicit |
| Validation | Runtime | Load-time |

---

## Reactive Modules

"""

        for module in reactive_modules:
            handlers = module.get("reactive", {}).get("handlers", {})

            content += f"""### {module['name']}

**Version:** {module['version']}
**Handlers:** {len(handlers)}

"""

            if handlers:
                content += "| Event Type | Handler Method |\n"
                content += "|------------|----------------|\n"

                for event_type, handler_method in sorted(handlers.items()):
                    content += f"| `{event_type}` | `{handler_method}` |\n"

            content += "\n"

        content += """
---

## Defining Reactive Handlers

```python
MODULE_MANIFEST = {
    "name": "reactive_demo",
    "reactive": {
        "enabled": True,
        "handlers": {
            "module.loaded": "on_module_loaded",
            "custom.test": "on_custom_event"
        }
    }
}

class ReactiveDemoModule:
    def on_module_loaded(self, event_context):
        # Handle module.loaded events
        return {"handled": True}

    def on_custom_event(self, event_context):
        # Handle custom.test events
        return {"handled": True}
```

---

## Benefits

- **Declarative:** Event handlers visible in manifest
- **Validated:** Handler methods checked at load time
- **Automatic:** No manual subscription code needed
- **Introspectable:** Easy to discover module's event handling

---

*Generated by AutoDocBuilder (FAZA D.1)*
"""

        return self.save_to_docs("reactive_modules.md", content)

    def render_state_md(self) -> str:
        """
        Generate state_management.md - state management documentation.

        Returns:
            Path to generated file
        """
        modules = self.model.get("modules", [])

        # Find modules with state
        stateful_modules = [m for m in modules if m.get("default_state")]

        content = f"""# State Management

**Modules with State:** {len(stateful_modules)}

The State Management system (FAZA 40) provides persistent, transactional state for modules.

---

## Features

- **Persistent:** State saved to disk automatically
- **Transactional:** Atomic updates with rollback support
- **Versioned:** State version tracking for migrations
- **Isolated:** Per-module storage sandboxing

---

## Modules with State

"""

        for module in stateful_modules:
            default_state = module.get("default_state", {})
            state_version = module.get("state_version", 1)

            content += f"""### {module['name']}

**State Version:** {state_version}
**Default State Keys:** {len(default_state)}

```json
{json.dumps(default_state, indent=2)}
```

"""

        content += """
---

## Using State in Modules

```python
class MyModule:
    def __init__(self, context, capabilities, state):
        self.state = state

    def run(self, payload):
        # Read state
        counter = self.state.get("counter", 0)

        # Update state
        self.state.set("counter", counter + 1)

        # State is automatically saved after run() completes

        return {"ok": True, "counter": counter + 1}
```

---

## State API

```python
# Read
value = state.get(key, default=None)

# Write
state.set(key, value)

# Update (merge)
state.update({key1: value1, key2: value2})

# Delete
state.delete(key)

# Manual operations
state.refresh()  # Reload from disk
state.save()     # Save to disk
state.rollback() # Revert to last saved
state.reset()    # Reset to default_state
```

---

## State Schema

Default state is declared in the manifest:

```python
MODULE_MANIFEST = {
    "default_state": {
        "counter": 0,
        "messages": [],
        "enabled": True
    },
    "state_version": 1
}
```

---

*Generated by AutoDocBuilder (FAZA D.1)*
"""

        return self.save_to_docs("state_management.md", content)

    def render_module_api_md(self) -> str:
        """
        Generate module_api.md - module API documentation.

        Returns:
            Path to generated file
        """
        modules = self.model.get("modules", [])

        content = f"""# Module API Reference

**Total Modules:** {len(modules)}

Complete API reference for all loaded modules.

---

"""

        for module in sorted(modules, key=lambda m: m["name"]):
            content += f"""## {module['name']}

**Version:** {module['version']}
**Phase:** {module['phase']}
**Entrypoint:** `{module['entrypoint']}`

{module.get('description', 'No description available.')}

### Capabilities

**Required:**
"""

            requires = module.get("capabilities", {}).get("requires", [])
            for cap in requires:
                content += f"- `{cap}`\n"

            optional = module.get("capabilities", {}).get("optional", [])
            if optional:
                content += "\n**Optional:**\n"
                for cap in optional:
                    content += f"- `{cap}`\n"

            # Lifecycle hooks
            hooks = module.get("hooks", {})
            enabled_hooks = [k for k, v in hooks.items() if v]

            if enabled_hooks:
                content += "\n### Lifecycle Hooks\n\n"
                for hook in enabled_hooks:
                    content += f"- `{hook}()`\n"

            # Event subscriptions
            event_subs = module.get("event_subscriptions", {})
            if event_subs:
                content += "\n### Event Subscriptions\n\n"
                content += "| Event Type | Handler Method |\n"
                content += "|------------|----------------|\n"
                for event_type, handler in event_subs.items():
                    content += f"| `{event_type}` | `{handler}` |\n"

            # Reactive handlers
            reactive = module.get("reactive", {})
            if reactive.get("enabled"):
                reactive_handlers = reactive.get("handlers", {})
                if reactive_handlers:
                    content += "\n### Reactive Handlers\n\n"
                    content += "| Event Type | Handler Method |\n"
                    content += "|------------|----------------|\n"
                    for event_type, handler in reactive_handlers.items():
                        content += f"| `{event_type}` | `{handler}` |\n"

            content += "\n---\n\n"

        content += """
*Generated by AutoDocBuilder (FAZA D.1)*
"""

        return self.save_to_docs("module_api.md", content)

    # ================================================================
    # FILE OPERATIONS
    # ================================================================

    def save_to_docs(self, filename: str, content: str) -> str:
        """
        Save Markdown document to docs directory.

        Args:
            filename: Document filename
            content: Markdown content

        Returns:
            Path to saved file
        """
        filepath = os.path.join(self.docs_path, filename)

        with open(filepath, "w") as f:
            f.write(content)

        return filepath

    def save_schema(self, filename: str, schema: Dict[str, Any]) -> str:
        """
        Save JSON schema to schemas directory.

        Args:
            filename: Schema filename
            schema: JSON schema dict

        Returns:
            Path to saved file
        """
        filepath = os.path.join(self.schemas_path, filename)

        with open(filepath, "w") as f:
            json.dump(schema, f, indent=2)

        return filepath
